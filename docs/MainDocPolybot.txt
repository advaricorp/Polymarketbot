Perfecto. Voy a preparar un documento extendido que complemente tu MASTER DOC incluyendo:

- Riesgos y limitaciones técnicas reales de Polymarket (API, CLOB, subgraphs, latencia, resolución, fees, oráculos, volumen real de liquidez, etc.).
- Consideraciones regulatorias y operativas (dentro del marco legal y uso permitido por la plataforma).
- Recomendaciones sobre la arquitectura técnica óptima para tu bot: microservicios (como pediste), mejores prácticas, estructura de módulos y opciones alternativas si aplican.
- Diagrama detallado en Mermaid.js con flujos de datos, WebSockets, módulo LLM, decisión, ejecución, gestión de estado, base de datos, etc.
- Recomendación concreta de instancia EC2 para MVP (coste mínimo) con opción a escalar.
- Sugerencias de stack Python para WebSockets, trading automation, LLM con API o distillado local (4090-ready).

Te aviso cuando tenga todo listo para que puedas compartirlo con tu agente o equipo de curso.

# Desarrollo de un Bot de Trading en Polymarket: Retos Técnicos y Arquitectura

## Introducción

En este documento técnico se exploran a fondo los desafíos y limitaciones de implementar un bot automatizado de trading en **Polymarket**, utilizando su API oficial ([Polymarket Documentation](https://docs.polymarket.com/#:~:text=Polymarket%27s%20Order%20Book%2C%20also%20referred,custodial%20exchange%20experience)). Polymarket es una plataforma de mercados predictivos (predicción de eventos) construida sobre blockchain (Polygon) que ofrece un **libro centralizado de órdenes** (Central Limit Order Book, **CLOB**) híbrido: las órdenes se casan fuera de cadena mediante un operador, mientras que la liquidación de las operaciones ocurre en la cadena de bloques de forma no custodial ([Polymarket Documentation](https://docs.polymarket.com/#:~:text=Polymarket%27s%20Order%20Book%2C%20also%20referred,custodial%20exchange%20experience)). 

A continuación, detallamos las consideraciones técnicas (latencia, WebSockets, oráculos, etc.), riesgos regulatorios y operativos, y proponemos una arquitectura de microservicios escalable para un bot de trading basado en análisis de volatilidad y modelos de lenguaje (LLMs). También se incluye un diagrama detallado en Mermaid.js y recomendaciones de infraestructura (ej. instancia EC2) y *stack* tecnológico apropiado para una implementación en Python. Todas las secciones incluyen referencias a la documentación oficial u otras fuentes autorizadas para respaldar las afirmaciones.

## Limitaciones Técnicas y Operativas en Polymarket

Desarrollar un bot en Polymarket conlleva entender varias limitaciones inherentes a la plataforma y su API:

### CLOB Híbrido y Operativa del Order Book

- **Arquitectura híbrida (off-chain/on-chain):** El **CLOB de Polymarket** es operado por un servidor central (*operator*) que ordena y empareja las órdenes fuera de la cadena, mientras que las operaciones resultantes se liquidan en un contrato inteligente on-chain ([Polymarket Documentation](https://docs.polymarket.com/#:~:text=Polymarket%27s%20Order%20Book%2C%20also%20referred,custodial%20exchange%20experience)). Esto ofrece alta velocidad y experiencia similar a un exchange centralizado, pero implica confianza en el operador para no censurar ni reordenar indebidamente las órdenes. Según la documentación, el operador no tiene privilegios para ejecutar operaciones no autorizadas (solo puede procesar las órdenes firmadas por los usuarios) ([Polymarket Documentation](https://docs.polymarket.com/#:~:text=The%20operator%20has%20no%20special,limit%20orders%20the%20user%20creates)). Si el operador fallara o actuara deshonestamente, los usuarios podrían dejar de interactuar con él e incluso **cancelar órdenes directamente on-chain** como mecanismo de seguridad ([Polymarket Documentation](https://docs.polymarket.com/#:~:text=The%20operator%20has%20no%20special,limit%20orders%20the%20user%20creates)). No obstante, esta dependencia añade un riesgo operativo: una caída del servicio del operador pausaría efectivamente el trading hasta ser restaurado.

- **Limitaciones de órdenes y liquidez:** Polymarket utiliza órdenes **límite** (limit orders) para todos los casos; las órdenes a mercado se simulan mediante órdenes límite “marketables” que toman el mejor precio disponible ([Polymarket Documentation](https://docs.polymarket.com/#:~:text=match%20at%20L633%20represented%20as,against%20current%20resting%20limit%20orders)) ([Polymarket Documentation](https://docs.polymarket.com/#:~:text=represented%20as%20,against%20current%20resting%20limit%20orders)). Esto significa que la **liquidez disponible** en el libro de órdenes es crucial. Si el bot envía una orden grande en un mercado poco líquido, puede no encontrar contrapartida completa, resultando en ejecuciones parciales o deslizamiento de precio. Por diseño, Polymarket **no impone un límite máximo de tamaño por operación** – cualquier tamaño se casará si hay contrapartes dispuestas ([Does Polymarket Have Trading Limits?](https://learn.polymarket.com/docs/guides/trading/no-limits/#:~:text=Does%20Polymarket%20Have%20Trading%20Limits%3F,and%20sellers%20of%20any%20amount))–, pero en la práctica el tamaño efectivo está limitado por la profundidad del mercado. Muchos mercados de Polymarket (especialmente los de eventos menos populares) tienen volumen bajo y amplios *spreads*, lo que restringe las oportunidades de arbitraje o trading de alta frecuencia. Incluso si Polymarket ha experimentado un crecimiento significativo en volumen en 2024 (p.ej. **$59.2M** de volumen en mayo 2024, frente a menos de $12M en cualquier mes de 2023 ([Polymarket Volume and Active Traders at All-Time Highs Due to Presidential Election - Unchained](https://unchainedcrypto.com/polymarket-volume-and-active-traders-at-all-time-highs-due-to-presidential-election/#:~:text=The%20monthly%20trading%20volume%20in,12%20million%20in%20a%20month))), la liquidez tiende a concentrarse en unos pocos mercados muy populares ([Polymarket Volume and Active Traders at All-Time Highs Due to Presidential Election - Unchained](https://unchainedcrypto.com/polymarket-volume-and-active-traders-at-all-time-highs-due-to-presidential-election/#:~:text=The%20new%20records%20for%20Polymarket,political%20system)). Un bot debe por tanto gestionar **rotación de mercados**, moviendo capital hacia los eventos con suficiente volumen e interés para evitar quedarse inactivo en mercados ilíquidos.

- **Emparejamiento y riesgo de cancelación:** Dado que el emparejamiento ocurre off-chain, una orden enviada se considera **“colocada”** inmediatamente si es válida, y puede ser emparejada casi instantáneamente por el motor del operador. La confirmación final de la operación ocurre cuando ésta se mintea en la cadena (transacción de swap en el contrato de Exchange de Polymarket). El API WebSocket de Polymarket refleja este flujo con estados de las operaciones: una operación pasa de *MATCHED* (emparejada off-chain) a *MINED*/*CONFIRMED* (confirmada on-chain) ([Polymarket Documentation](https://docs.polymarket.com/#:~:text=Emitted%20when%3A)). En casos de alta carga o congestión de la red Polygon, es posible que la confirmación on-chain se demore o que el operador deba reenviar la transacción (*status* “RETRYING”) ([Polymarket Documentation](https://docs.polymarket.com/#:~:text=Emitted%20when%3A)). Para el bot, esto implica que debe manejar estados de operación: por ejemplo, no asumir definitivamente una posición hasta recibir confirmación, y contemplar la posibilidad (aunque rara) de fallas de liquidación que requieran reintento. La latencia promedio de liquidación en Polygon (2–3 segundos por bloque) añade un pequeño retraso, pero generalmente el **matching off-chain es lo suficientemente rápido** para que la experiencia sea casi en tiempo real.

- **Oráculos de resolución de mercados:** Polymarket no resuelve los mercados internamente, sino que delega la resolución de los eventos a oráculos descentralizados. **La mayoría de mercados usan el oráculo optimista UMA** para resolver resultados de eventos (ej. elecciones, eventos deportivos, etc.), mientras que algunos mercados basados en precios usan el oráculo Pyth ([Polymarket Documentation](https://docs.polymarket.com/#:~:text=All%20market%20resolution%20is%20completely,are%20resoled%20via%20Pyth)). Esto garantiza una resolución **descentralizada y confiable** – por ejemplo, UMA permite que cualquiera proponga el resultado y un mecanismo de disputas (DVM) resuelve si hay desacuerdo ([Polymarket Documentation](https://docs.polymarket.com/#:~:text=,correct%20outcome%20should%20have%20been)). Sin embargo, desde la perspectiva del bot, esto implica **tiempo de resolución no inmediato**: típicamente, si nadie disputa, UMA confirma el resultado tras un período (p. ej. ~48 horas), pero si hay disputas podría demorar “varios días” en llegar a resolución final ([Polymarket Documentation](https://docs.polymarket.com/#:~:text=,correct%20outcome%20should%20have%20been)). El bot debe contemplar este retraso; tras la fecha de finalización del mercado, sus posiciones no se liquidarán hasta la resolución oficial del oráculo. Durante ese lapso, no podrá tradingar ese mercado (queda congelado en “resolución pendiente”). Esto no afecta las operaciones diarias del bot pero sí su **gestión de riesgo**: mantener posiciones hasta el final conlleva riesgo de un resultado disputado o incierto durante días. Además, el bot debe adherirse a las reglas del oráculo: un resultado final es definitivo, aunque difiera de expectativas, y no hay recurso más allá del proceso de disputa de UMA. Otro aspecto es que Polymarket publica todos los datos de resolución en la cadena (campo `ancillaryData` en las solicitudes del oráculo UMA) ([Polymarket Documentation](https://docs.polymarket.com/#:~:text=All%20market%20data%20necessary%20for,interfaces%2C%20automated%20trading%20systems%20etc)), lo cual es accesible públicamente; el bot podría incluso monitorear ese proceso si lo requiere (aunque generalmente basta con esperar el *update* de mercado resuelto vía la API).

### Acceso a Datos: API REST, WebSockets y Subgraph

- **API WebSocket (datos en tiempo real):** Polymarket ofrece canales WebSocket para obtener actualizaciones **en tiempo real** tanto de mercados como de la actividad del usuario ([Polymarket Documentation](https://docs.polymarket.com/#:~:text=The%20Polymarket%20CLOP%20API%20provides,market)). Existen dos canales principales:
  - **Canal de Mercado (`market`):** provee eventos del mercado público, como nuevas operaciones casadas, cambios en el libro de órdenes, etc., para los mercados suscritos.
  - **Canal de Usuario (`user`):** provee eventos filtrados a las órdenes y operaciones del usuario (requiere autenticación con API key) ([Polymarket Documentation](https://docs.polymarket.com/#:~:text=WSS%20Authentication)) ([Polymarket Documentation](https://docs.polymarket.com/#:~:text=Only%20connections%20to%20,Polygon%20account%27s%20CLOB%20api%20passphrase)).
  
  Un bot de trading aprovechará principalmente el canal de mercado para monitorizar precios, volumen y quizá el *order book*. Sin embargo, **suscribirse a múltiples mercados** puede requerir pasar varios IDs en la solicitud de suscripción ([Polymarket Documentation](https://docs.polymarket.com/#:~:text=Field%20Type%20Description%20auth%20Auth,User%20or%20Market)), lo que aumenta la complejidad si el bot quiere seguir *todos* los mercados simultáneamente. Habrá que gestionar la conexión WebSocket de forma robusta: reconectar en caso de caídas, **gestionar la latencia de red** para no perder mensajes (el servicio empuja datos casi en tiempo real, así que una conexión lenta podría rezagarse), y posiblemente consumir gran cantidad de eventos en mercados muy activos. Además, aunque no documentado explícitamente, es prudente asumir que existen **límites de uso** (rate limiting) para evitar sobrecargar el socket – por ejemplo, Polymarket podría desconectar clientes que suscriban demasiados mercados o envíen demasiadas órdenes por segundo, aunque no se publique la cifra exacta. Es recomendable usar la API WebSocket para recibir datos **push** en vez de hacer *polling* REST frecuente, tanto por eficiencia como para respetar cualquier limitación operativa de la API.

- **API REST (datos puntuales y libro de órdenes):** La API REST de Polymarket permite obtener la lista de mercados, precios actuales, libros de órdenes, histórico de trades, etc., mediante endpoints documentados ([Polymarket Documentation](https://docs.polymarket.com/#introduction#:~:text=,Get%20API%20Keys)) ([Polymarket Documentation](https://docs.polymarket.com/#introduction#:~:text=,Prices%20and%20Books)). El bot puede usar REST para tareas como: obtener un **snapshot inicial** del libro de órdenes de un mercado (vía `Get Book/Books`), consultar todos los mercados disponibles y sus estados ([Polymarket Documentation](https://docs.polymarket.com/#introduction#:~:text=,Get%20Books)), o acceder a datos agregados como el precio medio (*midpoint*) ([Polymarket Documentation](https://docs.polymarket.com/#introduction#:~:text=,56)). Una limitación a notar es que la API REST refleja principalmente el estado **on-chain confirmado**. Por ejemplo, un endpoint de histórico de trades mostrará trades una vez confirmados (minteados en la cadena), no instantáneamente al emparejarse off-chain. Por ello, para **detectar movimientos instantáneos** conviene utilizar el WebSocket. Asimismo, algunos datos de interés podrían requerir acumulación manual: por ejemplo, el volumen “real” en un periodo debe computarse sumando trades del histórico, ya que la API da datos brutos. Polymarket también expone un servicio denominado **Gamma** (una API pública) que indexa datos de mercados y metadatos (categorías, volumen histórico, etc.) ([Polymarket Documentation](https://docs.polymarket.com/#:~:text=All%20market%20data%20necessary%20for,interfaces%2C%20automated%20trading%20systems%20etc)). Gamma es de solo lectura y pensado para investigación o trading algorítmico, permitiendo consultar mercados activos, archivados, filtrar por volumen, liquidez, etc. ([Polymarket Documentation](https://docs.polymarket.com/#:~:text=)) ([Polymarket Documentation](https://docs.polymarket.com/#:~:text=archived%20boolean%20filter%20by%20archived,decimal%20filter%20by%20maximum%20volume)). Aunque útil para **datos históricos y filtrado**, Gamma no provee la inmediatez del WebSocket; el bot lo usaría más para análisis de contexto (ej. buscar mercados con ciertos criterios) que para decisiones en tiempo real.

- **Subgraphs (The Graph):** Polymarket dispone de subgráfos públicos (anunciados en su documentación y GitHub) que indexan los datos on-chain de la plataforma – por ejemplo, trades, volumen, usuarios, open interest, PnL, etc. Esto permite consultas vía GraphQL para obtener métricas históricas consolidadas. Por ejemplo, se pueden consultar volúmenes diarios, número de traders, etc., a través de dashboards en Dune o TheGraph ([Polymarket Volume and Active Traders at All-Time Highs Due to Presidential Election - Unchained](https://unchainedcrypto.com/polymarket-volume-and-active-traders-at-all-time-highs-due-to-presidential-election/#:~:text=The%20monthly%20trading%20volume%20in,12%20million%20in%20a%20month)). **Limitación:** El subgraph (al igual que Gamma) **no refleja las órdenes pendientes ni el estado off-chain**; solo capta lo que finalmente se ejecutó en la cadena. Por tanto, no es posible ver la composición completa del libro de órdenes vía subgraph, ni operaciones en tiempo real – esos datos viven en el servidor de Polymarket hasta que se confirman. Además, hay cierta **latencia de indexación**: típicamente unos segundos adicionales tras la confirmación en blockchain para que The Graph indexe el evento. Para un bot de trading, el subgraph es más útil en la fase de **análisis offline** (por ejemplo, evaluar estadísticas de mercados, backtesting con datos históricos de resultados y precios) que en la operativa en vivo. En resumen, el **bot deberá combinar**: WebSocket para precios en vivo, REST/Gamma para obtener información estructurada y estados actuales de mercados, y quizás subgraphs/Dune para validar volumen real o resultados históricos. Cada fuente tiene limitaciones de frescura y detalle, que deben balancearse.

- **Limitaciones de datos y precisión:** Cabe señalar que los precios en Polymarket se suelen expresar como **probabilidades implícitas** (ej. $0.60 = 60% de probabilidad de que ocurra el evento). Estos precios tienen una resolución limitada (tick mínimo) dado que finalmente corresponden a fracciones de la unidad de colateral. Según la documentación, existe un **tick size mínimo** (probablemente del orden de 0.1% o similar, aunque no se ha especificado aquí) ([Polymarket Documentation](https://docs.polymarket.com/#:~:text=minimum_order_size%20string%20minimum%20limit%20order,description%20string%20market%20description)). El bot debe manejar este redondeo: por ejemplo, no podrá colocar órdenes a $0.503, tendría que ser $0.50 o $0.505 dependiendo del tick. Además, Polymarket podría imponer un **tamaño mínimo de orden** (p. ej. 1 USDC) ([Polymarket Documentation](https://docs.polymarket.com/#:~:text=minimum_order_size%20string%20minimum%20limit%20order,description%20string%20market%20description)), evitando spam de órdenes muy pequeñas. Estas restricciones están diseñadas para mantener la integridad del mercado y deben respetarse en la lógica de la estrategia del bot.

### Comisiones, Tarifas y Costos de Operación

- **Estructura de fees:** Actualmente, Polymarket **no cobra comisiones de trading base (0 bps tanto para maker como taker)** en el CLOB ([Polymarket Documentation](https://docs.polymarket.com/#:~:text=Subject%20to%20change)) ([Polymarket Documentation](https://docs.polymarket.com/#:~:text=Volume%20Level%20Maker%20Fee%20Base,0%20USDC%200%200)). Su tabla de tarifas aparece con 0% para cualquier volumen (lo cual está “sujeto a cambio”) ([Polymarket Documentation](https://docs.polymarket.com/#:~:text=Subject%20to%20change)). Sin embargo, es importante entender que esto puede modificarse en el futuro; la infraestructura está preparada para cobrar fees en “basis points” cuando se active. Además, incluso con 0% de fee explícito, existen **costos implícitos**:
  - *Gas fees:* El operador de Polymarket es quien envía las transacciones on-chain para liquidar las operaciones. Se desconoce públicamente si Polymarket traslada ese costo al usuario; es probable que esté cubierto por ellos o compensado mediante alguna economía interna (posiblemente los fees cubrirían esto). Como bot, al menos debe contemplar costos al **depositar** fondos o retirar (esas sí son transacciones que uno realiza y paga gas en Polygon, aunque Polygon tiene fees muy bajos). Mantener suficiente **MATIC** en la cuenta para gas es necesario si el bot realizará retiros o acciones directas on-chain (como cancelar on-chain en caso extremo). Para las operaciones comunes vía API, el gas lo gestiona la plataforma.
  - *Spreads y slippage:* En ausencia de fees, el principal costo para un bot market-maker o trader es el *spread* bid-ask y el deslizamiento al ejecutar trades grandes. Un spread amplio actúa como una “comisión implícita” que el bot paga al cruzar el mercado. Por tanto, la estrategia del bot debe incluir estos factores en su modelo de ganancias y pérdidas (P&L). Si Polymarket introduce en el futuro, por ejemplo, un fee del 1% para takers (10 bps), eso impactaría directamente la rentabilidad de un bot de arbitraje o momentum, por lo que hay que estar atentos a cambios en la **política de fees** anunciados en la doc oficial ([Polymarket Documentation](https://docs.polymarket.com/#:~:text=Subject%20to%20change)).

- **Restricciones de API y autenticación:** Para **colocar órdenes**, Polymarket requiere autenticación. Hay dos niveles documentados:
  - **L1: Autenticación con clave privada (EIP-712)** – El bot firmaría cada orden con la clave privada del monedero (dirección Polygon) del usuario ([Polymarket Documentation](https://docs.polymarket.com/#introduction#:~:text=,24)). Esto asegura máxima seguridad (las órdenes son autorizadas explícitamente por la firma del usuario).
  - **L2: Autenticación con API Key** – Polymarket permite generar una API key/secret asociada a tu cuenta ([Polymarket Documentation](https://docs.polymarket.com/#introduction#:~:text=,24)). Esta se usa junto con una passphrase para autenticación tipo exchange centralizado (similar a API keys de Binance, etc.), facilitando la conexión especialmente en WebSocket (como se ve, el canal user pide `apiKey`, `secret`, `passphrase` ([Polymarket Documentation](https://docs.polymarket.com/#:~:text=Only%20connections%20to%20,Polygon%20account%27s%20CLOB%20api%20passphrase))). Internamente, es probable que las órdenes aún se firmen o validen contra la clave privada vinculada, pero la API key evita tener que firmar manualmente cada llamada.
  
  **Límites operativos:** La documentación no señala tasas máximas de órdenes por segundo ni llamadas REST, pero es sensato no exceder comportamientos normales para evitar ser baneado. Polymarket puede imponer *throttling* si un bot envía, por ejemplo, cientos de órdenes por segundo de forma constante. El bot deberá implementar una **cola de órdenes** y quizá algoritmos de *rate control* para cumplir con términos de uso. Asimismo, Polymarket aconseja usar su SDK oficial (clientes) para construir y firmar órdenes correctamente ([Polymarket Documentation](https://docs.polymarket.com/#:~:text=All%20orders%20are%20expressed%20as,suggests%20using%20the%20open%20source)), dado que la creación de la estructura EIP-712 correcta es compleja (incluye hash y firma de varios campos) ([Polymarket Documentation](https://docs.polymarket.com/#:~:text=All%20orders%20are%20expressed%20as,suggests%20using%20the%20open%20source)). Emplear estas utilidades oficiales reduce errores técnicos (ej. en cómputo de la firma) que podrían llevar a órdenes rechazadas.

### Volumen Real y Consideraciones de Mercado

- **Volumen y actividad de mercado:** Como se mencionó, el **volumen real de Polymarket varía mucho** con el interés en eventos concretos. Por ejemplo, en mayo de 2024 – impulsado por especulación electoral en EE.UU. – se alcanzó un récord mensual de **$59.2M** en volumen (12,800 traders activos), mientras que en meses de 2023 el volumen no pasaba de $12M ([Polymarket Volume and Active Traders at All-Time Highs Due to Presidential Election - Unchained](https://unchainedcrypto.com/polymarket-volume-and-active-traders-at-all-time-highs-due-to-presidential-election/#:~:text=The%20monthly%20trading%20volume%20in,12%20million%20in%20a%20month)). Esto significa que fuera de eventos “estrella”, la actividad puede ser modesta. Un bot orientado a volatilidad podría encontrar pocas oportunidades en mercados planos con volumen bajo. También debe tener en cuenta que los **mercados expiran**: cada mercado tiene una fecha de finalización (cuando ocurre el evento o deja de aceptarse trading). Después de eso, no hay más trading en ese mercado – el bot debe cerrar o re-evaluar sus posiciones antes del cierre, o planificar mantener hasta la resolución (según su estrategia). Una práctica común sería **rotar capital**: cuando un mercado concluye, retirar USDC o reinvertir en nuevos mercados abiertos. Operativamente, esto implica que el bot necesite monitorear continuamente la lista de mercados activos (usando la API Gamma o REST ([Polymarket Documentation](https://docs.polymarket.com/#:~:text=Get%20markets)) ([Polymarket Documentation](https://docs.polymarket.com/#:~:text=Name%20Type%20Description%20limit%20number,used%20multiple%20times%20to%20fetch))) para descubrir nuevos mercados y detectar cuándo unos cierran (campo `closed` o `end_date`). La **volatilidad** en Polymarket también puede ser estacional: eventos políticos pueden tener fuertes oscilaciones de precio con las noticias, mientras que otros (ej. predicciones climáticas) tienen movimientos lentos. El bot debe adaptar sus algoritmos de **análisis de volatilidad** a distintos regímenes de mercado.

- **Resolución y post-mercado:** Tras la resolución oficial de un mercado por el oráculo, las posiciones se liquidan automáticamente (los tokens de resultado “Yes/No” se convierten en la cantidad correspondiente de USDC dependiendo del resultado). En ese momento, ya no existe libro de órdenes ni trading – cualquier posición abierta se convierte en saldo de USDC (si acertó) o queda sin valor (si era el lado perdedor). Un riesgo operativo aquí es **mantener posiciones en mercados que puedan ser invalidados**. Polymarket, a través de UMA, contempla la posibilidad de que una pregunta sea ambigua o necesite clarificaciones ([Polymarket Documentation](https://docs.polymarket.com/#:~:text=)). Si un mercado se resuelve en un resultado “N/A” o “invalid” (por ejemplo, la pregunta no tuvo respuesta clara), puede que ambas posiciones se liquiden a $1 (reembolso) o alguna regla especial. El bot tendría que manejar estos casos excepcionales, aunque son raros. En general, ceñirse a mercados bien definidos minimiza este riesgo.

## Riesgos Regulatorios y Operativos

Al operar un bot en Polymarket, es fundamental considerar el entorno regulatorio y las políticas de la plataforma. Sin caer en alarmismo, estos son algunos riesgos a mitigar, **asumiendo que el bot opera dentro del marco legal y de los términos de Polymarket**:

### Cumplimiento Legal y Restricciones Geográficas

- **Regulación de mercados predictivos:** Polymarket ofrece esencialmente **apuestas binarias sobre eventos**, lo cual en ciertos países se considera un producto financiero regulado (derivados, opciones) o juego de azar. En EE.UU., la CFTC clasificó los mercados de Polymarket como **swaps no registrados**, lo que derivó en una investigación y multa en 2022 ([CFTC Fines Crypto Betting Service Polymarket $1.4M for Unregistered Swaps](https://www.coindesk.com/policy/2022/01/03/cftc-fines-crypto-betting-service-polymarket-14m-for-unregistered-swaps#:~:text=The%20Commodity%20Futures%20Trading%20Commission,to%20register%20with%20the%20regulator)). Polymarket alcanzó un acuerdo con la CFTC, pagando **$1.4M de multa** y cerrando todos los mercados no conformes para usuarios estadounidenses ([CFTC Fines Crypto Betting Service Polymarket $1.4M for Unregistered Swaps](https://www.coindesk.com/policy/2022/01/03/cftc-fines-crypto-betting-service-polymarket-14m-for-unregistered-swaps#:~:text=The%20Commodity%20Futures%20Trading%20Commission,to%20register%20with%20the%20regulator)) ([CFTC Fines Crypto Betting Service Polymarket $1.4M for Unregistered Swaps](https://www.coindesk.com/policy/2022/01/03/cftc-fines-crypto-betting-service-polymarket-14m-for-unregistered-swaps#:~:text=The%20CFTC%20announced%20the%20penalties,S)). Desde entonces, la empresa reforzó su cumplimiento y evita ofrecer servicios en jurisdicciones restringidas. Para un desarrollador de bot, esto significa que si operas desde una región donde estos mercados no son legales (ej. EE.UU.), **no debes usar Polymarket** con dinero real. Incluso si intentaras, Polymarket podría detectar y bloquear la actividad. De hecho, la API cuenta con un endpoint de *ban status* que indicará si se requiere certificación de residencia ([Polymarket Documentation](https://docs.polymarket.com/#:~:text=Access%20status)). Muchos usuarios fuera de EE.UU. fueron solicitados a proveer prueba de residencia y firmar una declaración de no-ser de EE.UU., so pena de poner la cuenta en modo “solo cerrar” ([Polymarket Documentation](https://docs.polymarket.com/#:~:text=Please%20regularly%20check%20the%20access,should%20be%20market%20to%20false)). Un bot que opere con una cuenta Polymarket deberá cumplir estos pasos de KYC si se le requieren, en un plazo de 14 días, o arriesgarse a que la cuenta quede bloqueada para nuevas operaciones ([Polymarket Documentation](https://docs.polymarket.com/#:~:text=Access%20status)). **Mitigación:** Asegurarse de operar desde una cuenta verificada, en una jurisdicción permitida, y monitorear comunicaciones de Polymarket sobre cualquier actualización de términos de servicio.

- **Cambios regulatorios futuros:** El panorama legal para predicción de eventos puede cambiar. Por ejemplo, si alguna jurisdicción comienza a perseguir a participantes en estos mercados, podría afectar la operación del bot (por ejemplo, un exchange que bloquee la API en ciertas regiones, o requerimientos de reporte). Polymarket ya implementa geofencing (bloqueo de IP/registros de EE.UU.) y es probable que cumpla con cualquier orden futura de retirar mercados específicos (como sucedió con mercados no conformes en 2022 ([CFTC Fines Crypto Betting Service Polymarket $1.4M for Unregistered Swaps](https://www.coindesk.com/policy/2022/01/03/cftc-fines-crypto-betting-service-polymarket-14m-for-unregistered-swaps#:~:text=The%20CFTC%20announced%20the%20penalties,S))). Mientras el bot se mantenga dentro de lo legal, el principal riesgo es **disponibilidad**: en caso extremo de cese de operaciones de Polymarket en tu país, los fondos podrían tener que ser retirados rápidamente. Es sensato no mantener en Polymarket más fondos de los que estás dispuesto a tener bloqueados temporalmente si hubiera un incidente regulatorio. Aun así, cabe destacar que Polymarket continúa operando globalmente de forma sólida después de su reestructuración legal, con “un equipo de cumplimiento excepcional” según declaraciones de la empresa ([CFTC settles enforcement action against DeFi platform Polymarket | DLA Piper](https://www.dlapiper.com/en/insights/publications/2022/1/cftc-settles-enforcement-action-against-defi-platform-polymarket#:~:text=As%20part%20of%20the%20settlement%2C,procedures%E2%80%9D%20because%20of%20the%20investigation)) ([CFTC settles enforcement action against DeFi platform Polymarket | DLA Piper](https://www.dlapiper.com/en/insights/publications/2022/1/cftc-settles-enforcement-action-against-defi-platform-polymarket#:~:text=announced%20that%20it%20has%20%E2%80%9Cbuilt,procedures%E2%80%9D%20because%20of%20the%20investigation)), lo cual indica que mientras actúes dentro de sus reglas, el riesgo de interrupción brusca es bajo.

- **Cumplimiento de términos de servicio:** Además de la ley, el bot debe respetar los **Términos de Servicio** de Polymarket ([Polymarket Documentation](https://docs.polymarket.com/#:~:text=)). Esto incluye no intentar manipular mercados, no aprovechar vulnerabilidades de la plataforma, ni hacer *scraping* de datos privados de otros usuarios. Polymarket fomenta el desarrollo abierto (han abierto su API y repositorios), por lo que los bots están permitidos e incluso incentivados, siempre que actúen de buena fe. No obstante, comportamientos como **wash trading** (auto-operar para inflar volumen), uso de información privilegiada sobre resoluciones (si alguien supiera de antemano un resultado y tratara de explotarlo masivamente), o intentar esquivar restricciones de localización, podrían ocasionar sanciones. En resumen: mantener el bot operando **ética y transparentemente** – sus ganancias deben venir de diferenciales legítimos de información o modelo, no de trampas.

### Riesgos Operativos de la Plataforma

- **Disponibilidad y tiempo de inactividad:** Como toda plataforma, Polymarket puede experimentar caídas o mantenimiento. Un riesgo operativo es que el **API no esté disponible temporalmente** – por ejemplo, mantenimiento programado del CLOB (quizá anunciados en el canal de status ([Polymarket Documentation](https://docs.polymarket.com/#:~:text=Status))) o interrupciones imprevistas. El bot debe manejar errores de conexión gracefully: si el API REST falla o el WebSocket se desconecta, el bot debería pausar trading, esperar y reconectar cuando vuelva. Continuar operando a ciegas podría ser peligroso. Polymarket provee una página de status (status-clob.polymarket.com) ([Polymarket Documentation](https://docs.polymarket.com/#:~:text=Status)) que el bot (o el operador humano) podría monitorear para saber si la infraestructura está en modo solo-lectura o cerrado. Por ejemplo, Polymarket podría poner el libro en *close-only* (solo cerrar) durante eventos de migración o si algún problema serio ocurre, impidiendo nuevas posiciones. Un módulo de **monitoreo** (discutido más adelante) debería alertar si no se reciben datos en X tiempo o si se detectan errores de API consecutivos.

- **Integridad del oráculo y retrasos:** Aunque los oráculos UMA/Pyth son robustos, existe el riesgo de un **retraso anómalo en la resolución** (por disputa prolongada, falla técnica en UMA, etc.). Para el bot, esto significaría fondos inmovilizados más tiempo de lo previsto en ese mercado. En casos extremos, podría haber un **riesgo de resolución incorrecta** (muy bajo, dado el mecanismo de disputa, pero por completar: si un oráculo fuera comprometido temporalmente). UMA tiene incentivos económicos para corregir cualquier resolución mala, pero tardaría días. El bot debe aceptar que no tiene control sobre esto; la mejor práctica es diversificar en varios mercados para que un fallo en uno no sea catastrófico, y quizás evitar mercados donde la resolución pueda ser polémica o difícil de determinar objetivamente.

- **Seguridad de fondos y contratos:** Polymarket ha sido auditado y su contrato Exchange es público ([Polymarket Documentation](https://docs.polymarket.com/#:~:text=the%20audit%20report%20here)) ([Polymarket Documentation](https://docs.polymarket.com/#:~:text=,Exchange%20contract%20documentation)). Aun así, en DeFi siempre existe un riesgo (aunque pequeño) de **exploits** o bugs. Un hack al contrato de Polymarket podría congelar o perder fondos. Dado el historial, esto no ha ocurrido en Polymarket, pero un bot prudente podría no mantener el 100% de sus activos en Polymarket todo el tiempo. Operar con la cantidad necesaria y retirar ganancias periódicamente a una wallet controlada externamente reduce exposición. Asimismo, proteger la **clave privada** del bot es crítico: si alguien la obtuviera, podría retirar todos los fondos. Por eso, si se despliega en un servidor, se deben seguir buenas prácticas (no exponer la key en código, usar variables de entorno seguras, etc.). Opcionalmente, el bot podría usar **contratos proxy/metacartas** para limitar qué puede hacer la clave (por ejemplo, un contrato que solo permita operar en Polymarket y no retiros arbitrarios), aunque esto agrega complejidad.

- **Riesgo de modelo y operativo del bot:** Más allá de Polymarket, el propio bot puede ser fuente de riesgo. Un bug en la lógica podría causar órdenes erróneas (ej. comprar cuando debería vender), lo que puede llevar a pérdidas. Es importante implementar **stop-loss automáticos** y límites – por ejemplo, si el PnL neto baja cierta cantidad en poco tiempo, que el bot se detenga y alerte. También llevar registros detallados ayudará a depurar comportamientos inesperados. Tener un período de **paper trading** (simulación) o pruebas con fondos muy pequeños es recomendable antes de escalar.

En resumen, los riesgos regulatorios y operativos existen pero son manejables. Polymarket opera dentro de un nicho aún emergente (predicción descentralizada) con relativa tolerancia regulatoria fuera de EE.UU., y técnicamente brinda herramientas para que un bot funcione de manera segura siempre y cuando el desarrollador tome precauciones de robustez y cumplimiento.

## Arquitectura Técnica Propuesta (Microservicios)

Para construir un bot de trading automatizado basado en análisis de volatilidad y modelos de lenguaje (LLM) que opere en Polymarket, se sugiere una arquitectura modular de microservicios. Esta arquitectura facilita la escalabilidad y el mantenimiento, permitiendo actualizar componentes (por ejemplo, mejorar el modelo de análisis o agregar nuevas fuentes de datos) sin reescribir todo el sistema. A continuación se describen los **módulos principales** propuestos y sus responsabilidades:

### 1. Servicio de **Ingesta de Datos**

Este servicio centraliza la **captura de información** de diversas fuentes, proporcionando un flujo unificado de datos al resto del sistema. Sus funciones incluyen:

- **Conexión a Polymarket (WebSocket y REST):** Establece la conexión WebSocket al canal de mercado de Polymarket para recibir en **streaming** los eventos relevantes: operaciones ejecutadas, actualizaciones de precios y posiblemente cambios significativos en el libro (por ejemplo, órdenes grandes añadidas o canceladas, si la API las envía). Filtra los mensajes recibidos y los traduce a un formato común (p. ej., un objeto Python o JSON con campos: mercado, precio, volumen, tipo de evento). Adicionalmente, usa la **API REST** de Polymarket para consultas puntuales: al iniciar, podría descargar la lista completa de mercados activos y sus datos base (ID, pregunta, estado, precios actuales), o periódicamente solicitar el libro de órdenes completo de ciertos mercados para sincronización. La ingesta debe manejar autenticación cuando sea necesario (por ejemplo, si se opta por recibir también eventos del canal *user* para saber cuándo las órdenes del bot se ejecutan, deberá autenticarse con API key y secret ([Polymarket Documentation](https://docs.polymarket.com/#:~:text=Only%20connections%20to%20,Polygon%20account%27s%20CLOB%20api%20passphrase))). Un punto crítico es la **resiliencia**: reconectar automáticamente al WebSocket si se cae, y quizás implementar un pequeño *buffer* de eventos en memoria o en cola para asegurar que los consumidores no pierdan datos si hay pequeños retrasos.

- **Ingesta de noticias y datos externos:** Además de datos de mercado, el bot requiere alimentar información **fundamental** para sus decisiones. Esto incluye noticias, tweets u otros indicadores externos que puedan afectar la probabilidad de los eventos. El servicio de ingesta puede incorporar conexiones a APIs de noticias (por ejemplo, API de noticias financieras o RSS feeds de periódicos para eventos relevantes). Otra fuente podría ser **foros/redes sociales** (Twitter, Reddit) dependiendo del tipo de mercado – aunque esto puede añadirse en etapas posteriores si es útil. Estas noticias se capturan y envían para análisis de lenguaje al módulo de análisis de mercado. Para optimizar, la ingesta podría filtrar noticias por palabras clave relacionadas con mercados activos (p. ej., si hay un mercado “¿Ganará X candidato?” buscar noticias que mencionen a ese candidato). También puede marcar cada noticia con los mercados potencialmente afectados.

- **Publicación en bus interno:** En una arquitectura de microservicios, es útil que la ingesta **emita los datos hacia un canal interno** al que otros módulos se suscriben. Esto puede ser un bus de eventos (por ejemplo, RabbitMQ, Redis Pub/Sub, o Kafka si el volumen es alto), o incluso endpoints HTTP si se opta por menos acoplamiento. La idea es que el Servicio de Ingesta actúe como *publisher* de dos tipos principales de mensajes:
  - **Eventos de mercado**: contiene identificación del mercado, timestamp, último precio (o mejor bid/ask), volumen reciente, etc., cada vez que llega una actualización de Polymarket.
  - **Eventos de noticias**: contiene la noticia (título, resumen o texto completo si disponible), con metadatos y posible asociación a un mercado o categoría.
  
  Estas publicaciones desencadenarán el procesamiento en los siguientes módulos. Este diseño permite escalar la ingesta independientemente; si en el futuro queremos paralelizar la recepción (ej. múltiples conexiones WS por grupos de mercado), se podría tener varias instancias de ingesta que todas publiquen al bus de eventos.

### 2. Servicio de **Análisis de Mercado**

Este módulo recibe la información cruda de la ingesta y realiza cálculos y estimaciones que informarán la toma de decisiones. Combina dos enfoques: cuantitativo (volatilidad, patrones) y cualitativo (interpretación de noticias via LLM):

- **Cálculo de volatilidad y métricas cuantitativas:** A partir del flujo de precios y volúmenes, este servicio calcula indicadores en tiempo real, como volatilidad histórica (por ejemplo, desviación estándar de cambios de precio en ventanas móviles), volatilidad implícita (en mercados de predicción es básicamente la intensidad de movimientos recientes), **tendencias** (momentum), rupturas de rango de precio, y cualquier otra señal técnica. Podría implementar detectores de **anomalías**: por ejemplo, un salto repentino de precio o volumen en un mercado puede señalar que acaba de salir una noticia importante – señal que puede correlacionarse con el módulo de noticias. Estas métricas se pueden calcular usando librerías Python (NumPy, pandas, tal vez TA-Lib para indicadores técnicos adaptados a series de probabilidad). Se almacena el resultado en un estado interno o se envía junto con la siguiente señal al módulo de decisión.

- **Análisis con LLM de noticias y contexto:** La parte “fundamental” del análisis recae en utilizar **Modelos de Lenguaje** (LLMs) para interpretar la información textual. Cuando la ingesta provee una noticia, el servicio de análisis invoca a un LLM (que puede ser local o vía API) para extraer información relevante y cuantificar su impacto en ciertos mercados. Por ejemplo, si llega una noticia sobre *“El candidato X lidera encuestas”*, el LLM podría inferir que en el mercado “¿Ganará X las elecciones?” la probabilidad debería aumentar. Técnicamente, esto se puede lograr de varias formas:
  - *Prompt directo:* Enviar al LLM un prompt del tipo: _“Noticia: {texto}. Pregunta del mercado: ‘{pregunta del mercado}’. ¿Aumenta o disminuye la probabilidad de que la respuesta sea Sí, y en qué magnitud (pequeña, moderada, grande)?”_. El LLM respondería una estimación cualitativa (ej. “Aumenta ligeramente la probabilidad de Sí”). Esta salida cualitativa luego se transforma en una señal (p. ej., +5 puntos porcentuales estimados).
  - *Embeddings y similitud:* Otra técnica es usar **embeddings** de texto. El servicio puede generar embeddings vectoriales tanto de las noticias como de la descripción de cada mercado/pregunta, utilizando un modelo de lenguaje local más ligero (por ejemplo, un modelo tipo SentenceTransformer). Con una base vectorial (vector database, como **ChromaDB** que Polymarket Agents utiliza ([GitHub - Polymarket/agents: Trade autonomously on Polymarket using AI Agents](https://github.com/Polymarket/agents#:~:text=APIs))), se puede hacer *matching* de qué mercados están más relacionados con la noticia (cálculo de similitud de coseno entre embedding de la noticia y embeddings de las preguntas de mercado). Luego, podría haber un pequeño modelo o regla que asigne un efecto: p. ej., si la noticia es altamente relevante al mercado, asume que debería mover el precio hacia 0 o 1 con cierta intensidad.
  - *LLM especializado o fine-tuned:* A largo plazo, podría entrenarse un modelo (incluso un modelo pequeño tipo GPT-2 o GPT-Neo fine-tuned) para que dada una noticia y un mercado, prediga el nuevo “precio justo” del mercado. Esto requeriría datos históricos para entrenar (noticias pasadas y reacciones de mercado), lo cual puede ser complejo. En un MVP, se puede usar un **LLM general (como GPT-4 via API, o Llama 2 local)** con buenos *prompts* para que evalúe la información de manera razonable.

- **Salida del análisis:** El resultado de este módulo será una serie de **indicadores enriquecidos por mercado**. Por ejemplo, para cada mercado que el bot sigue, el análisis podría producir cada minuto: probabilidad subjetiva calculada (ej. “LLM cree que debería valer 65%”), volatilidad actual (ej. “volatilidad alta, precio moviéndose ±5% diario”), discrepancia entre probabilidad implícita del mercado y la estimada (ej. mercado está a 50%, análisis indica debería ser 60% → señal de compra). Estas salidas pueden publicarse en otro canal interno o almacenarse en una estructura accesible al servicio de decisiones. Es importante que el análisis también evalúe **confianza** o calidad de señal: por ejemplo, si la noticia es un rumor poco confiable, quizás darle un peso bajo. En general, este servicio actúa como “cerebro analítico”, transformando datos en conocimiento accionable.

### 3. Servicio de **Lógica de Decisiones**

Con los insumos del análisis de mercado, este módulo determina **qué acciones de trading ejecutar**. Es el núcleo de la estrategia del bot, donde se aplican reglas de negocio y gestión de riesgo:

- **Estrategia de entrada/salida:** Basándose en las señales (diferenciales de probabilidad, tendencias, etc.), decide **tomar posición** en un mercado (entrar) o **cerrar posición** (salir). Por ejemplo, si el módulo de análisis indica que el mercado valora en 0.50 (50%) un evento pero el LLM/news sugiere que la probabilidad real debería ser 0.70, la lógica de decisión podría generar una orden de **compra** de tokens “Sí” (Yes) hasta un cierto monto o hasta que el precio suba cerca de 0.70. Inversamente, si detecta sobrevaloración, podría vender/short (en Polymarket, vender tokens “Sí” equivale a comprar “No”). Esta lógica debe incorporar **stop-loss**: si el bot entró esperando que el precio suba a 0.70 pero en cambio baja a 0.40 (quizá su análisis estuvo equivocado o ocurrió noticia contraria), debería tener un umbral para salir y limitar pérdidas. El stop-loss podría ser una caída del X% desde el precio de entrada. Igualmente, puede haber **take-profit** o stop-gain: si ya se obtuvo la ganancia prevista, quizás conviene salir para asegurarla.

- **Tamaño de posiciones y risk management:** La decisión no es solo qué hacer sino **cuánto** comprar o vender. Se necesita una política de asignación de capital: por ejemplo, nunca arriesgar más del Y% del capital en un solo mercado (para evitar que un resultado desfavorable anule todo el portafolio), y mantener cierto balance entre mercados. El concepto de **rotación de mercados** se aplica aquí: el bot puede periódicamente evaluar el rendimiento y potencial de cada mercado y decidir redistribuir capital. Por ejemplo, si un mercado va a resolverse pronto y ya no ofrece oportunidad (su precio está ~0.99 o ~0.01, casi decidido), la lógica podría decir “vende lo que tengamos allí y libera USDC para otros mercados emergentes”. También considerará **liquidar antes de resolución** si, por ejemplo, la predicción se ha movido en contra y no se desea especular hasta el final.

- **Multiples estrategias y prioridades:** Podría darse que el bot implemente varias sub-estrategias: una basada en volatilidad (ej. *market-making* en mercados quietos para ganar spread), otra basada en noticias (trading direccional en mercados con nueva información). La lógica de decisiones debe conciliar potenciales conflictos (p. ej., el market-making quiere poner órdenes en ambos lados del libro, pero la estrategia de noticias dice “claramente comprar Sí”). Esto puede manejarse asignando **prioridades** o **modos**. Por ejemplo, en mercados con noticia reciente, activar modo direccional agresivo; en mercados sin noticias, replegarse a modo market-making pasivo. El diseño con microservicios incluso permite que cada estrategia sea un sub-módulo que proponga órdenes, y una capa superior decida en función de todas las propuestas cuáles ejecutar. En un MVP, puede ser más simple: implementar primero la estrategia principal (ej. aprovechar discrepancias LLM vs mercado) y luego añadir otras.

- **Generación de órdenes específicas:** Una vez decidida una acción (comprar/vender X unidades en mercado Y), la lógica prepara la orden en el formato requerido. Esto incluye determinar el tipo de orden: probablemente el bot usará **órdenes limit** siempre, para controlar precios. Si quiere ejecutar inmediatamente, definirá una orden limit con precio lo suficientemente agresivo para cruzar (por ejemplo, si desea comprar ya hasta 0.60, y el mejor ask actual es 0.58, puede colocar limit 0.60 que tomará los asks hasta ese nivel). Si en cambio es market-making, colocará órdenes limit en ambos lados quizás ligeramente dentro del spread. La lógica decide también **vigencia** de la orden: Polymarket soporta órdenes GTC (hasta cancelación) y GTD (hasta una hora/fecha) ([Polymarket Documentation](https://docs.polymarket.com/#:~:text=match%20at%20L882%20,has%20already%20been%20fulfilled%20or)). Para un bot, GTC está bien para la mayoría, cancelando manualmente cuando cambie la situación. Pero para ciertos eventos (ej. predecir datos económicos que salen a tal hora), podría poner GTD hasta justo antes del anuncio para no quedarse expuesto.

- **Salida hacia ejecución:** Finalmente, este servicio envía las órdenes decididas al servicio de Ejecución de Órdenes, pasándole los detalles: mercado, lado (buy/sell), tamaño, precio límite, vigencia, etc. Es importante registrar internamente la intención: p.ej., marcar que ahora el bot **tiene una orden abierta** en tal mercado, para evitar duplicar envíos o exceder el presupuesto. Puede llevar una pseudo-cartera interna para saber cuántos tokens “Sí” o “No” y cuánta USDC tiene después de cada operación (aunque el módulo de Ejecución confirmará con eventos reales).

### 4. Servicio de **Ejecución de Órdenes**

Este módulo se encarga de interactuar directamente con la **API de Polymarket para enviar, cancelar y consultar órdenes**. Actúa como la mano del bot en el mercado:

- **Recepción de órdenes de la lógica:** Al recibir una instrucción (por ejemplo, “Colocar orden de comprar 100 YES de mercado X a precio ≤ $0.60”), el servicio de ejecución procede a construir la orden con los parámetros apropiados. Dado que Polymarket requiere EIP-712 signing, aquí es donde se utiliza la **clave privada** o la API Key del usuario para autenticar la orden. Una forma eficiente es usar las utilidades oficiales de Polymarket: por ejemplo, la librería Python `py-clob-client` y `python-order-utils` disponibles en pip ([Polymarket Documentation](https://docs.polymarket.com/#:~:text=pip%20install%20py)) ([GitHub - Polymarket/agents: Trade autonomously on Polymarket using AI Agents](https://github.com/Polymarket/agents#:~:text=Related%20Repos)). Estas librerías manejan detalles como serializar la orden, calcular `feeRateBps` (que en la actualidad sería 0, pero hay que incluir el campo ([Polymarket Documentation](https://docs.polymarket.com/#:~:text=match%20at%20L872%20feeRateBps%20yes,yes%20string%20hex%20encoded%20signature))) y firmar con la clave privada. El *Ejecución Service* debe almacenar de forma segura las credenciales (idealmente, la clave privada en memoria o en un almacén seguro). Si se usa API Key en lugar de firma directa, se enviará la orden junto con los headers de autenticación de API Key.

- **Llamadas a la API REST de órdenes:** Polymarket API ofrece endpoints para crear y gestionar órdenes ([Polymarket Documentation](https://docs.polymarket.com/#introduction#:~:text=,if%20some%20orders%20are%20scoring)) ([Polymarket Documentation](https://docs.polymarket.com/#introduction#:~:text=,Prices%20and%20Books)). Por ejemplo, **Create and Place Order**, **Cancel Order**, etc. El servicio de ejecución realiza la petición HTTP correspondiente (POST/DELETE) con los datos de orden. Tras enviar, recibirá una respuesta que puede indicar éxito (orden aceptada) o error (por ejemplo, orden inválida por precio fuera de rango, tamaño insuficiente, fondos insuficientes, etc.). Debe manejar estos casos: si error, notificar al módulo de decisión (que podría ajustar la estrategia o reprocesar). Si éxito, guardar el **ID de la orden** retornado y monitorear su estado.

- **Seguimiento de estado y relleno (fills):** Una vez colocada, una orden puede ser ejecutada total o parcialmente. Aquí entra la importancia del WebSocket de usuario: el servicio de ejecución debe suscribirse (o recibir vía ingesta) los mensajes de trade del canal *user*, de modo que se entere cuando sus órdenes se cumplen ([Polymarket Documentation](https://docs.polymarket.com/#:~:text=)) ([Polymarket Documentation](https://docs.polymarket.com/#:~:text=,bdca11c0a465%22%2C%20%22price%22%3A%20%220.57%22%20%7D)). Alternativamente, podría consultar periódicamente las órdenes activas via REST (`Get Active Orders`) ([Polymarket Documentation](https://docs.polymarket.com/#introduction#:~:text=,Statuses)), pero WS es más inmediato. Al detectar un trade propio, actualiza el registro: por ejemplo, la orden #123 se llenó con 50/100, resta 50 por llenar. Si se llena completamente, marca la orden como cerrada. Si la estrategia requiere cancelar órdenes pendientes (por cambio de plan o stop-loss), el módulo enviará la instrucción de cancelación (que sería otra llamada a la API). Polymarket provee endpoints para **cancelar todas** las órdenes, o por mercado, lo que puede ser útil en escenarios de detener rápidamente el bot ([Polymarket Documentation](https://docs.polymarket.com/#introduction#:~:text=,38)) ([Polymarket Documentation](https://docs.polymarket.com/#introduction#:~:text=,Get%20Sampling%20Markets)). 

- **Gestión de balance:** A medida que se ejecutan trades, el servicio de ejecución puede actualizar un estado de **balances**: cuánta USDC disponible, cuántos tokens de resultado en cada mercado. Esto podría almacenarse en el servicio de persistencia también, pero tenerlo aquí permite a la lógica de decisiones consultarlo rápidamente antes de enviar nuevas órdenes (p.ej., no enviar orden de compra si ya no queda USDC suficiente). Se puede obtener el balance también directamente de la blockchain (pidiendo el saldo de ERC-20 USDC y de tokens outcome en el wallet), pero mantener un registro interno actualizado por los trades es más inmediato. De todos modos, una reconciliación ocasional con los datos reales (ej. al inicio del día, consultar on-chain los saldos) es buena práctica para detectar desvíos.

En resumen, el Servicio de Ejecución encapsula toda la interacción con Polymarket y asegura que el bot coloque órdenes válidas y reaccionar a su cumplimiento.

### 5. Servicio de **Registro y Monitoreo**

La operación autónoma del bot requiere visibilidad y trazabilidad. Este módulo se encarga de **loggear, reportar y alertar** sobre la actividad y salud del sistema:

- **Logging detallado:** Cada acción o evento importante debe quedar registrada. Por ejemplo: recepción de una nueva señal de análisis, decisión tomada (ej. “Comprar 100 YES en mercado X a 0.60”), orden enviada (con ID timestamp), fill recibido (ej. “Orden 123 fill 50@0.58”), cancelaciones, etc., así como mensajes de error (timeout de API, desconexión WS, etc.). El servicio de registro puede unificar todos estos logs de distintos módulos (Ingesta, Análisis, Decisión, Ejecución) ya sea recibiendo directamente sus mensajes de log vía RPC o que todos escriban en un mismo sistema de logging. Se recomienda usar un formato estructurado (JSON) o al menos bien formateado con timestamps para facilitar luego filtrado y debugging.

- **Dashboard de monitoreo:** Sobre estos datos, se puede construir un **dashboard** o reportes periódicos. Por ejemplo, un panel web (o incluso un simple terminal/console) que muestre en tiempo real:
  - PnL actual del bot (ganancias/perdidas realizadas, y valor de posiciones abiertas).
  - Exposición por mercado (cuánto Yes/No hold en cada uno).
  - Estadísticas: número de trades ejecutados hoy, fees pagadas (si hubiera), etc.
  - Estado de conexiones (WS conectada, latencia media, última actualización recibida).
  Este servicio podría insertar métricas en una base de datos de series de tiempo o enviar a un sistema de monitoreo (como Prometheus/Grafana) para visualizar. Sin embargo, para un MVP, un panel simple mostrando los datos básicos es suficiente.

- **Alertas y seguridad:** El monitoreo también implica generar **alertas** si algo va mal. Por ejemplo, si el bot detecta que la conexión a Polymarket se perdió por más de X minutos, podría enviar un email o mensaje (quizá integrando con un servicio como Slack, Telegram o simplemente imprimiendo una alerta audible) para que un operador intervenga. Otra alerta: si el PnL cae por debajo de cierto umbral (posible bug o mercado adverso), o si un módulo se cierra inesperadamente. Implementar alertas requiere que el servicio de registro reciba *heartbeats* o señales de vida de los módulos; una arquitectura sencilla es que cada módulo envíe periódicamente un “sigo vivo” al monitor, y si alguno se calla, se dispara una alerta.

- **Reporting y logs históricos:** Además del monitoreo en vivo, mantener **logs históricos** es valioso para posteriormente analizar el desempeño del bot. El servicio podría rotar logs diarios y guardarlos en almacenamiento persistente (por ejemplo S3 o en la propia base de datos). De esta forma, se puede luego evaluar qué decisiones fueron buenas o malas, e incluso re-simular escenarios con datos reales (lo que ayuda a mejorar los algoritmos).

### 6. Módulo de **Persistencia de Datos**

Aunque cada servicio puede tener sus propios datos en memoria, es esencial centralizar cierta información en almacenamiento persistente para durabilidad y análisis:

- **Base de datos principal:** Se recomienda una base de datos relacional o de tiempo real para almacenar:
  - **Histórico de operaciones**: cada trade efectuado (timestamp, mercado, tamaño, precio, lado, etc.), con referencia a la orden que lo generó, y el resultado (realizada, cancelada, etc.).
  - **Estados de órdenes abiertas**: órdenes pendientes en el libro, para recuperar al reiniciar el bot qué órdenes había.
  - **Balances y PnL**: registros periódicos (ej. cada hora) de los balances del bot y PnL acumulado. También cada vez que se cierra un trade se puede calcular la ganancia/pérdida realizada e insertarla.
  - **Datos de mercado**: podría almacenar snapshots de precios, volatilidad calculada, y las estimaciones del LLM, para construir un dataset propio. Esto ayuda si se quieren hacer análisis offline o entrenar modelos en el futuro con los datos recogidos en vivo.
  - **Noticias procesadas**: guardar las noticias relevantes con la interpretación que dio el LLM y las acciones que provocó, es útil para evaluar la eficacia de esa parte del sistema.

  Una base de datos SQL como **PostgreSQL** funcionaría bien, ya que puede manejar datos relacionales (trades, órdenes) y con extensiones de series de tiempo (Timescale) podría gestionar métricas de mercado. Alternativamente, una base NoSQL o de series puras (InfluxDB, etc.) podría complementar para métricas de alta frecuencia, pero no es estrictamente necesario al inicio.

- **Almacenamiento de vectores/embeddings:** Si se implementa la componente de vectorización de noticias y contexto (embeddings), podría desplegarse una base de datos vectorial como **ChromaDB** o **FAISS**. Esta base permite almacenar los embeddings de las noticias y recuperarlos rápidamente por similitud. Polymarket Agents, por ejemplo, integra Chroma para este propósito ([GitHub - Polymarket/agents: Trade autonomously on Polymarket using AI Agents](https://github.com/Polymarket/agents#:~:text=APIs)). Esta BD puede considerarse parte del módulo de análisis (ya que se usa allí), pero desde la perspectiva de persistencia, sí es un dato que conviene guardar (así se puede reiniciar el bot sin perder la “memoria” de noticias pasadas).

- **Backups y redundancia:** Dado que esta base de datos contendrá el registro completo de la actividad del bot (valioso tanto para auditoría como para no perder PnL histórico), se debe asegurar persistencia con backups periódicos. Si se usa un servicio administrado (p. ej., RDS en AWS para PostgreSQL), aprovechar sus snapshots automatizados.

- **Logs persistentes:** El módulo de persistencia también se encargaría de guardar los logs consolidados que reciba del servicio de monitoreo, o al menos aquellos de nivel importante (errores críticos, alertas). Esto complementa la base de datos principal, ya que los logs suelen almacenarse en ficheros o en un índice tipo ELK (Elasticsearch) si se desea capacidad de búsqueda avanzada. En un MVP, puede ser tan simple como archivos rotativos en disco.

Con todos estos componentes, la arquitectura de microservicios propuesta lograría separar preocupaciones: ingesta de datos, análisis, toma de decisiones, ejecución de trades, monitoreo y almacenamiento. A continuación, se ilustra dicha arquitectura en un diagrama Mermaid para visualizar la interacción entre módulos:

### Diagrama de Arquitectura del Sistema (Mermaid)

flowchart LR
    subgraph Fuentes_Externas
        A[API Polymarket REST/WSS] -->|Datos de mercado| Ingesta
        B[Fuentes de Noticias] -->|Noticias| Ingesta
    end

    subgraph Microservicios_del_Bot
        Ingesta[[Servicio de Ingesta de Datos]]
        Analisis[[Servicio de Análisis de Mercado]]
        Decision[[Servicio de Lógica de Decisiones]]
        Ejecucion[[Servicio de Ejecución de Órdenes]]
        Monitoreo[[Servicio de Registro y Monitoreo]]
        DB[(Base de Datos y Almacenamiento)]

        Ingesta -->|Eventos de mercado y noticias| Analisis
        Analisis -->|Indicadores y señales| Decision
        Decision -->|Órdenes| Ejecucion
        Ejecucion -->|Confirmaciones y resultados| Decision
        Ejecucion -->|Eventos de trade| Ingesta
        Ejecucion -->|Órdenes y trades| DB
        Analisis -->|Métricas e insights| DB
        Ingesta -->|Histórico de precios - Opcional| DB
        Monitoreo -->|Logs y alertas| DB
        Monitoreo ---|Lectura de datos: PnL y estado| DB
        Monitoreo -->|Dashboard y alertas| Desarrollador
    end

    Ejecucion -->|Órdenes buy/sell| A


*(Diagrama: Interacción entre los componentes del bot. Las fuentes externas – Polymarket y noticias – alimentan al servicio de ingesta. Los datos fluyen luego hacia análisis, decisión y ejecución de órdenes. La ejecución comunica con la API de Polymarket para realizar trades, y los resultados se retroalimentan al sistema. El módulo de monitoreo y la base de datos están transversales, registrando información y proporcionando visibilidad.)*

## Infraestructura: Despliegue MVP y Escalabilidad

Al iniciar este proyecto en fase **MVP** (Producto Mínimo Viable), es preferible mantener la infraestructura sencilla y de bajo coste, pero con posibilidad de escalar conforme aumente el volumen de trading y la complejidad. Dado que usaremos principalmente Python y posiblemente contenedores para los microservicios, una buena elección es desplegar en **AWS EC2** con una instancia pequeña para comenzar:

- **Instancia EC2 recomendada (MVP):** Una instancia tipo **t3.small** (burstable) o **t3.medium** de AWS es adecuada para iniciar. Estas instancias ofrecen 2 vCPUs y 2 GB RAM (small) o 4 GB RAM (medium) a un coste muy bajo (en 2025, unos ~$10-$20 USD mensuales para *small*), suficiente para correr todos los componentes del bot en contenedores ligeros o procesos separados. La familia T3 es de propósito general con capacidad de ráfaga, lo que funciona bien dado que el bot normalmente tendrá carga baja-moderada (escuchando datos, pequeñas inferencias LLM) y ocasionalmente ráfagas cuando haya muchas noticias o trades simultáneos. Alternativamente, si se prefiere ahorrar aún más y las dependencias lo permiten, una **t4g.small (Graviton ARM)** ofrece rendimiento similar con costo ligeramente menor, aunque habría que asegurarse de compatibilidad de librerías Python con ARM (muchas lo soportan hoy en día).

- **Consideraciones de rendimiento:** Un t3.small/medium puede manejar fácilmente las tareas de red (WebSocket, REST calls) y cálculos ligeros (volatilidad, etc.). La parte más pesada potencialmente es el **LLM**. En la fase inicial, se podría usar la API de OpenAI u otro servicio en la nube, delegando así el cómputo pesado fuera de la instancia. Si se decide usar un modelo local, conviene comenzar con uno pequeño (por ejemplo, un modelo de 7B parámetros quantizado) que pueda correr en CPU. Un LLM de 7B INT4 puede requerir ~4GB de RAM, por lo que una t3.medium (4GB) sería el mínimo para cargarlo. En ese caso quizá sea necesario ampliar a una **t3.large (2 vCPU, 8GB)** para dar holgura. Sin embargo, dado que la mayoría del tiempo el modelo no estará activo, se podría cargar/destruir bajo demanda, aunque eso añade latencia. Para MVP, lo más pragmático es: usar un modelo alojado (API) para la parte de LLM, y luego evaluar mover a local.

- **Escalabilidad vertical:** Si el volumen de trading crece (más mercados, más operaciones por segundo), la primera medida puede ser **subir de tamaño la instancia**. AWS permite cambiar a instancias más potentes, como *t3.large* (8GB), *t3.xlarge* (16GB) o moverse a familias de mayor rendimiento constante como **m5.large** (2 vCPU, 8GB pero con CPU más potente sin bursting) o *c5.large* (optimizada en CPU). Estas opciones dan más capacidad de procesamiento para manejar, por ejemplo, un modelo de lenguaje más grande o múltiples hilos de análisis concurrentes. La decisión entre vertical (más grande) u horizontal (más instancias) depende del arquitecto: dado que planteamos microservicios, eventualmente podríamos **separar módulos en distintas instancias**. Por ejemplo, correr el servicio de Ingesta+Ejecución en un nodo, y análisis LL.M. en otro con más CPU/RAM o incluso GPU. 

- **Escalabilidad horizontal y contenedores:** A medida que la complejidad sube, considerar usar **Docker** para empaquetar cada microservicio y un orquestador simple (docker-compose al inicio, o **AWS ECS/EKS** si se busca alta disponibilidad). Un camino de escalado sería: desplegar cada servicio en un contenedor separado y, de ser necesario, replicar algunos. Por ejemplo, si se siguen cientos de mercados, podríamos ejecutar múltiples instancias del servicio de análisis en paralelo, cada una procesando un subconjunto, comunicándose vía cola. AWS ECS Fargate podría correr contenedores on-demand. Pero estas optimizaciones solo serían necesarias en caso de crecer mucho; para un MVP y primeras etapas, **una sola instancia EC2 manejando todo** es viable.

- **Red y seguridad:** La instancia EC2 debería estar en una VPC segura. Es recomendable restringir puertos: solo abrir los necesarios si queremos acceder a un dashboard web (puerto 80/443) o SSH para administración. Las conexiones salientes a Polymarket (HTTPS, WSS) y a APIs de noticias se harán sobre puertos 443. Se debe asegurar que la instancia tenga acceso a internet (salida) pero, por seguridad, limitar cualquier exposición pública no requerida. También, manejar las claves (Polymarket private key / API keys) en **AWS Systems Manager (Parameter Store)** o AWS Secrets Manager sería buena práctica, para no hardcodearlas en la máquina.

En resumen, **comenzar con un t3.small (2 vCPU, 2GB)** es suficiente si usamos APIs externas para LLM, o un **t3.medium (4GB)** si queremos alojar componentes de IA sencillos localmente. Esto mantiene costos bajos. Conforme el bot genere más actividad o utilice modelos más complejos, se puede escalar verticalmente (instancias más grandes) u horizontalmente (dividir servicios en varias instancias) apoyándonos en contenedores y servicios administrados de AWS.

## Stack Tecnológico Recomendado (Principalmente Python)

Dado que el desarrollo será mayoritariamente en Python, escoger un stack acorde a sus fortalezas (rápida integración, gran ecosistema de ciencia de datos y ML, y librerías para WebSockets) es ideal. A continuación las tecnologías y bibliotecas sugeridas para cada componente:

- **Python 3.9+**: Base del desarrollo. Se recomienda usar una versión relativamente reciente (3.9 o superior) para aprovechar mejoras en asyncio, typing, etc. 

- **Clientes de Polymarket**: Aprovechar las herramientas oficiales:
  - **`py-clob-client`**: SDK oficial en Python para el CLOB de Polymarket ([Polymarket Documentation](https://docs.polymarket.com/#:~:text=pip%20install%20py)). Simplifica la conexión y peticiones a la API. Este cliente probablemente gestione autenticación y las llamadas REST bajo el capó, exponiendo métodos Pythonic para obtener mercados, colocar órdenes, etc. Utilizarlo evitará errores y mantendrá la compatibilidad con cambios de la API.
  - **`python-order-utils`**: Utilidad oficial para generar y firmar órdenes ([GitHub - Polymarket/agents: Trade autonomously on Polymarket using AI Agents](https://github.com/Polymarket/agents#:~:text=Related%20Repos)). Dado que firmar con EIP-712 puede ser complejo, esta librería ofrece funciones para preparar la estructura de la orden y obtener la firma con la clave privada. Integrarla asegurará que las órdenes del bot estén correctamente formadas.
  - **Polymarket WebSocket**: Si el `py-clob-client` no cubre la parte de subscripción WSS, se puede usar librerías Python de WebSockets. Dos opciones: **`websocket-client`** (sencilla, estilo callback) o **`websockets`** (basada en asyncio, ideal si estructuramos todo el bot de forma asíncrona). Dado que manejaremos múltiples concurrentemente (escuchar WS, procesar datos, llamar API), Python **`asyncio`** es muy pertinente. Podríamos hacer el Servicio de Ingesta con un bucle asyncio que escucha el socket y publica a otros coros.

- **Framework de concurrencia y comunicación**:
  - Para **microservicios**, podemos utilizar **FastAPI** o **Falcon** para exponer endpoints REST internos entre servicios (por ejemplo, el servicio de decisión podría recibir vía HTTP las señales del análisis, pero esto quizá es overhead dentro de la misma máquina). Otra ruta es usar **RabbitMQ** (con Kombu o Pika en Python) o **Redis Pub/Sub** to broadcast messages internally. Redis es ligero y fácil; una instancia local de Redis puede manejar la comunicación entre hilos/procesos con baja latencia. 
  - Dado que en MVP quizás todo corre en un proceso principal, podríamos implementar microservicios de manera lógica (por módulos/clases) orquestrados por threads o tareas asyncio. No obstante, para seguir la arquitectura propuesta, separar en procesos o contenedores es útil. En tal caso, **Docker** será empleado para contener cada servicio con su propio entorno (por ejemplo, un container para ingest & websockets, otro para LLM, etc.).
  - Python’s **asyncio** library será fundamental para multitarea cooperativa: permite tener corutinas para escuchar websockets, para procesar noticias en segundo plano, etc., sin requerir múltiples threads (evitando complicaciones con GIL si las tareas son I/O-bound principalmente).

- **Procesamiento de datos y ML**:
  - **NumPy/Pandas**: para manejar cálculos de estadísticas, volatilidad, etc. Pandas puede usarse para mantener ventanas deslizantes de precios y calcular indicadores fácilmente.
  - **TA-Lib** (opcional): Librería de indicadores técnicos; podría usarse para calcular RSI, bandas de Bollinger sobre la serie de precios de probabilidad, lo que puede indicar volatilidad o confianza del mercado.
  - **Scikit-learn/Statsmodels**: para cualquier modelo estadístico simple, regresiones o detección de rupturas en series.
  - **NLTK/Spacy** (opcional): para procesamiento de texto ligero (por ejemplo, extraer entidades de una noticia y relacionarlas a mercados).
  
- **LLM e IA**:
  - **OpenAI API**: Para empezar rápido con análisis de noticias, la API de OpenAI (GPT-4/GPT-3.5) es muy potente. Usando la biblioteca `openai` en Python, se puede llamar al modelo con un prompt y obtener respuesta. Esto evita la complejidad de hosting, a cambio de costo por token y dependencia externa. En un MVP, se podría limitar su uso a cuando haya noticias críticas para no incurrir en mucho gasto.
  - **Hugging Face Transformers**: Si se opta por un modelo local, la biblioteca `transformers` permite cargar modelos pre-entrenados. Por ejemplo, un modelo como **Llama 2 7B** (o una variante especializada en análisis de texto) en formato cuantizado (usando libraries como `bitsandbytes` para int8/int4) podría correr en CPU. También hay modelos más pequeños como **DistilBERT** para embeddings, o **GPT-NEO 1.3B** que podrían evaluarse. Para generar embeddings, **Sentence Transformers** (e.g., `all-MiniLM-L6-v2`) es eficiente y tiene integración fácil con `sentence-transformers` library.
  - **LangChain**: Esta librería facilita la implementación de cadenas de prompts, consultas a LLM y manejo de contexto. Polymarket Agents la menciona ([GitHub - Polymarket/agents: Trade autonomously on Polymarket using AI Agents](https://github.com/Polymarket/agents#:~:text=%2A%20py,source%20vector%20database)). Podríamos usar LangChain para orquestar, por ejemplo, un **Retrieval-Augmented Generation**: almacenar conocimiento (embeddings de noticias previas) en **ChromaDB** (vector store) y proveer contexto relevante al LLM cuando analiza una nueva noticia. Esto permitiría que el LLM tenga en cuenta información pasada (ej. “hace 1 semana pasó X, ahora esta noticia Y sale…”). Sin embargo, esta complejidad puede reservarse para iteraciones futuras; inicialmente, un solo prompt directo por noticia podría bastar.

- **Bases de Datos y almacenamiento**:
  - **PostgreSQL**: Como base de datos principal relacional. Con el driver `psycopg2` o SQLAlchemy (ORM) en Python para interactuar. SQLAlchemy con Pydantic models puede facilitar definir objetos (Trade, Order, Market, etc.) y guardarlos. 
  - **TimescaleDB**: Si se integra mucho de series de tiempo, Timescale (extensión de Postgres) permite optimizaciones en consultas de series (útil para analizar performance).
  - **Redis**: Además de pub/sub, Redis puede usarse para almacenamiento rápido de ciertos estados (caché de últimos precios, por ejemplo, para cálculo rápido de indicadores sin siempre ir a Postgres).
  - **Vector DB (Chroma)**: Si implementamos embeddings, **Chroma** es una elección natural (usada oficialmente ([GitHub - Polymarket/agents: Trade autonomously on Polymarket using AI Agents](https://github.com/Polymarket/agents#:~:text=APIs))). Es sencillo de integrar (pip install chromadb) y permite almacenar y buscar embeddings con Python fácilmente. Alternativamente, FAISS (Facebook AI Similarity Search) via `faiss` library if we prefer an in-memory approach, though Chroma can persist to disk.

- **Framework web para Dashboard**:
  - Podríamos hacer algo minimalista con **FastAPI** to serve a small web dashboard or API for the bot’s status. FastAPI can serve HTML or JSON endpoints that a simple frontend (maybe a static HTML/JS or a small React/Vue app) uses to display metrics. This would allow checking the bot status in real-time in a browser. If not, even a command-line TUI (text UI) with libraries like `urwid` or just logs could suffice in MVP. But since readability and monitoring are important, a web dashboard with charts (possibly using Plotly or Chart.js via a FastAPI backend) would be nice to have.

- **Testing y DevOps**:
  - Use of **Pytest** for testing the strategy logic and components individually (simulate certain market scenarios).
  - **Docker** for environment consistency. Write a Dockerfile for each service or a single one that runs supervisord to run all (though splitting is cleaner).
  - **GitHub Actions** or similar for CI, ensuring that changes do not break connectivity with Polymarket API (maybe using a sandbox or dry-run mode if exists).
  - **Deployment**: For AWS, one could use Terraform or AWS CDK to define the infrastructure (EC2, security groups, etc.), or at least an EC2 setup script to install Docker and run containers.

En definitiva, el stack propuesto es **Python-centric**: aprovecha librerías de trading/finanzas, integra directamente con las herramientas oficiales de Polymarket ([GitHub - Polymarket/agents: Trade autonomously on Polymarket using AI Agents](https://github.com/Polymarket/agents#:~:text=Related%20Repos)), y utiliza frameworks modernos para IA y microservicios. Esto brinda un equilibrio entre facilidad de desarrollo y capacidad de incorporar componentes avanzados (como IA) de manera relativamente sencilla. Conforme el bot crezca, se pueden introducir optimizaciones en otros lenguajes (por ejemplo, reescribir la ingesta de WebSocket en **Node.js** o **Rust** si se busca menor latencia, o mover partes del análisis intensivo a **C++**/Numba) pero Python es suficiente para alcanzar un MVP funcional y más.

## Conclusión

Este documento ha desglosado los desafíos técnicos de interactuar con Polymarket para un bot de trading automatizado, y ha delineado una arquitectura escalable para abordarlos. Resumiendo los puntos clave:

- Polymarket ofrece un CLOB híbrido con ventajas (no-custodia, rápida ejecución) pero impone considerar latencia de cadena, oráculos de resolución y liquidez limitada en ciertos mercados. El bot debe navegar estas limitaciones con gestión de órdenes cuidadosa y buena disponibilidad de datos (via WebSocket y API).
- Operar el bot implica cumplir normativas: evitar jurisdicciones prohibidas y adherirse a Términos de Servicio para no incurrir en sanciones. Polymarket ya ha enfrentado escrutinio regulatorio ([CFTC Fines Crypto Betting Service Polymarket $1.4M for Unregistered Swaps](https://www.coindesk.com/policy/2022/01/03/cftc-fines-crypto-betting-service-polymarket-14m-for-unregistered-swaps#:~:text=The%20Commodity%20Futures%20Trading%20Commission,to%20register%20with%20the%20regulator)) y ha implementado controles (KYC de no-US ([Polymarket Documentation](https://docs.polymarket.com/#:~:text=Access%20status))), por lo que el bot debe funcionar dentro de esos márgenes.
- La arquitectura modular propuesta separa la ingesta de datos, el análisis (volatilidad + LLM), la toma de decisiones, la ejecución de trades, y el monitoreo/persistencia. Esto permite desarrollar, probar y escalar cada componente de forma independiente, aumentando la resiliencia general del sistema.
- Un diagrama de flujo en Mermaid resume la interacción: desde las fuentes externas (Polymarket, noticias) hasta los microservicios internos y la base de datos/logs que consolidan la información.
- Se sugirió comenzar el despliegue en una instancia AWS EC2 económica (t3.small/medium) para MVP, con vistas a escalar verticalmente u horizontalmente según demanda. 
- Por último, se recomendó un stack tecnológico centrado en Python, aprovechando tanto herramientas oficiales de Polymarket (SDK, utils) como librerías punteras de data science y NLP/IA (asyncio, FastAPI, LangChain, ChromaDB, etc.) para implementar un bot inteligente que combine análisis cuantitativo y cualitativo.

Con esta guía, un desarrollador tendrá un **mapa detallado** para construir e implementar un bot de trading en Polymarket, minimizando sorpresas técnicas y operativas, y con la flexibilidad para evolucionar la solución a medida que crezca el volumen o se incorporen nuevas fuentes de ventaja (por ejemplo, modelos de IA más avanzados). Siguiendo las referencias a la documentación oficial proporcionadas, se puede profundizar en cada aspecto (como endpoints específicos de la API, detalles de oráculos UMA, o métricas de volumen histórico) durante la implementación práctica. ¡Manos a la obra con el desarrollo del bot! ([Polymarket Documentation](https://docs.polymarket.com/#:~:text=Polymarket%27s%20Order%20Book%2C%20also%20referred,custodial%20exchange%20experience)) ([Polymarket Documentation](https://docs.polymarket.com/#:~:text=All%20market%20data%20necessary%20for,interfaces%2C%20automated%20trading%20systems%20etc))

